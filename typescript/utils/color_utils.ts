/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is automatically generated. Do not modify it.

import * as mathUtils from './math_utils';

/**
 * Color science utilities.
 *
 *  Utility methods for color science constants and color space
 *  conversions that aren't HCT or CAM16.
 */

/**
 * Converts a color from RGB components to ARGB format.
 */
export function argbFromRgb(red: number, green: number, blue: number): number {
  return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>>
      0;
}

/**
 * Returns the alpha component of a color in ARGB format.
 */
export function alphaFromArgb(argb: number): number {
  return argb >> 24 & 255;
}

/**
 * Returns the red component of a color in ARGB format.
 */
export function redFromArgb(argb: number): number {
  return argb >> 16 & 255;
}

/**
 * Returns the green component of a color in ARGB format.
 */
export function greenFromArgb(argb: number): number {
  return argb >> 8 & 255;
}

/**
 * Returns the blue component of a color in ARGB format.
 */
export function blueFromArgb(argb: number): number {
  return argb & 255;
}

/**
 * Returns whether a color in ARGB format is opaque.
 */
export function isOpaque(argb: number): boolean {
  return alphaFromArgb(argb) >= 255;
}

/**
 * Returns the sRGB to XYZ transformation matrix.
 */
export function srgbToXyz(): number[][] {
  return [
    [0.41233895, 0.35762064, 0.18051042],
    [0.2126, 0.7152, 0.0722],
    [0.01932141, 0.11916382, 0.95034478],
  ];
}

/**
 * Returns the XYZ to sRGB transformation matrix.
 */
export function xyzToSrgb(): number[][] {
  return [
    [3.2406, -1.5372, -0.4986],
    [-0.9689, 1.8758, 0.0415],
    [0.0557, -0.204, 1.057],
  ];
}

/**
 * Converts a color from ARGB to XYZ.
 */
export function argbFromXyz(x: number, y: number, z: number): number {
  const linearRgb = mathUtils.matrixMultiply([x, y, z], xyzToSrgb());
  const r = delinearized(linearRgb[0]);
  const g = delinearized(linearRgb[1]);
  const b = delinearized(linearRgb[2]);
  return argbFromRgb(r, g, b);
}

/**
 * Converts a color from XYZ to ARGB.
 */
export function xyzFromArgb(argb: number): number[] {
  const r = linearized(redFromArgb(argb));
  const g = linearized(greenFromArgb(argb));
  const b = linearized(blueFromArgb(argb));
  return mathUtils.matrixMultiply([r, g, b], srgbToXyz());
}

/**
 * Converts a color represented in Lab color space into an ARGB
 *  integer.
 */
export function argbFromLab(l: number, a: number, b: number): number {
  const whitePoint = whitePointD65();
  const fy = (l + 16.0) / 116.0;
  const fx = a / 500.0 + fy;
  const fz = fy - b / 200.0;
  const xNormalized = labInvf(fx);
  const yNormalized = labInvf(fy);
  const zNormalized = labInvf(fz);
  const x = xNormalized * whitePoint[0];
  const y = yNormalized * whitePoint[1];
  const z = zNormalized * whitePoint[2];
  return argbFromXyz(x, y, z);
}

/**
 * Converts a color from ARGB representation to L*a*b*
 *  representation.
 *
 *
 *  @param argb the ARGB representation of a color
 *  @return a Lab object representing the color
 */
export function labFromArgb(argb: number): number[] {
  const whitePoint = whitePointD65();
  const xyz = xyzFromArgb(argb);
  const xNormalized = xyz[0] / whitePoint[0];
  const yNormalized = xyz[1] / whitePoint[1];
  const zNormalized = xyz[2] / whitePoint[2];
  const fx = labF(xNormalized);
  const fy = labF(yNormalized);
  const fz = labF(zNormalized);
  const l = 116.0 * fy - 16;
  const a = 500.0 * (fx - fy);
  const b = 200.0 * (fy - fz);
  return [l, a, b];
}

/**
 * Converts an L* value to an ARGB representation.
 *
 *
 *  @param lstar L* in L*a*b*
 *  @return ARGB representation of grayscale color with lightness
 *  matching L*
 */
export function argbFromLstar(lstar: number): number {
  const fy = (lstar + 16.0) / 116.0;
  const fz = fy;
  const fx = fy;
  const kappa = 24389.0 / 27.0;
  const epsilon = 216.0 / 24389.0;
  const lExceedsEpsilonKappa = lstar > 8.0;
  const y = lExceedsEpsilonKappa ? fy * fy * fy : lstar / kappa;
  const cubeExceedEpsilon = fy * fy * fy > epsilon;
  const x = cubeExceedEpsilon ? fx * fx * fx : lstar / kappa;
  const z = cubeExceedEpsilon ? fz * fz * fz : lstar / kappa;
  const whitePoint = whitePointD65();
  return argbFromXyz(
      x * whitePoint[0],
      y * whitePoint[1],
      z * whitePoint[2],
  );
}

/**
 * Computes the L* value of a color in ARGB representation.
 *
 *
 *  @param argb ARGB representation of a color
 *  @return L*, from L*a*b*, coordinate of the color
 */
export function lstarFromArgb(argb: number): number {
  const y = xyzFromArgb(argb)[1] / 100.0;
  const e = 216.0 / 24389.0;
  if (y <= e) {
    return 24389.0 / 27.0 * y;
  } else {
    const yIntermediate = Math.pow(y, 1.0 / 3.0);
    return 116.0 * yIntermediate - 16.0;
  }
}

/**
 * Converts an L* value to a Y value.
 *
 *  L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 *  L* measures perceptual luminance, a linear scale. Y in XYZ
 *  measures relative luminance, a logarithmic scale.
 *
 *
 *  @param lstar L* in L*a*b*
 *  @return Y in XYZ
 */
export function yFromLstar(lstar: number): number {
  const ke = 8.0;
  if (lstar > ke) {
    return Math.pow((lstar + 16.0) / 116.0, 3.0) * 100.0;
  } else {
    return lstar / 24389.0 / 27.0 * 100.0;
  }
}

/**
 * Linearizes an RGB component.
 *
 *
 *  @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
 *  channel
 *  @return 0.0 <= output <= 100.0, color channel converted to
 *  linear RGB space
 */
export function linearized(rgbComponent: number): number {
  const normalized = rgbComponent / 255.0;
  if (normalized <= 0.040449936) {
    return normalized / 12.92 * 100.0;
  } else {
    return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
  }
}

/**
 * Delinearizes an RGB component.
 *
 *
 *  @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
 *  linear R/G/B channel
 *  @return 0 <= output <= 255, color channel converted to regular
 *  RGB space
 */
export function delinearized(rgbComponent: number): number {
  const normalized = rgbComponent / 100.0;
  let delinearized = 0.0;
  if (normalized <= 0.0031308) {
    delinearized = normalized * 12.92;
  } else {
    delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
  }
  return mathUtils.clampInt(0, 255, Math.round(delinearized * 255.0));
}

/**
 * Returns the standard white point; white on a sunny day.
 *
 *
 *  @return The white point
 */
export function whitePointD65(): number[] {
  return [95.047, 100.0, 108.883];
}

function labF(t: number): number {
  const e = 216.0 / 24389.0;
  const kappa = 24389.0 / 27.0;
  if (t > e) {
    return Math.pow(t, 1.0 / 3.0);
  } else {
    return (kappa * t + 16) / 116;
  }
}

function labInvf(ft: number): number {
  const e = 216.0 / 24389.0;
  const kappa = 24389.0 / 27.0;
  const ft3 = ft * ft * ft;
  if (ft3 > e) {
    return ft3;
  } else {
    return (116 * ft - 16) / kappa;
  }
}
